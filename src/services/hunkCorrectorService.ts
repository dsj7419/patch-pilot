/* --------------------------------------------------------------------------
 *  PatchPilot â€” Hunk Header Corrector Service
 * ----------------------------------------------------------------------- */

import { DiffParsedPatch } from '../types/patchTypes';

/**
 * Structure for reporting individual hunk corrections
 */
export interface HunkCorrection {
  filePath: string;
  hunkIndex: number;
  originalOld: number;
  correctedOld: number;
  originalNew: number;
  correctedNew: number;
}

/**
 * Structure for reporting all corrections made during processing
 */
export interface CorrectionReport {
  correctionsMade: boolean;
  corrections: HunkCorrection[];
}
import { extractFilePath } from '../applyPatch';

/**
 * Corrects hunk headers in parsed patches by recounting the actual lines in each hunk
 * and updating the declared line counts if they don't match.
 * 
 * This is particularly useful for diffs generated by AI that may have incorrect line counts
 * in hunk headers (e.g., @@ -10,5 +10,6 @@).
 * 
 * Line counting rules:
 * - Context lines (starting with ' '): Count toward both old and new line counts
 * - Removed lines (starting with '-'): Count toward old line count only
 * - Added lines (starting with '+'): Count toward new line count only
 * - Special marker "\ No newline at end of file": Not counted in either total
 * 
 * @param patches - ReadonlyArray of parsed patches to correct
 * @returns An object containing the corrected patches and a detailed correction report
 */
export function correctHunkHeaders(
  patches: ReadonlyArray<DiffParsedPatch>
): { correctedPatches: DiffParsedPatch[], correctionDetails: CorrectionReport } {
  // Initialize the correction report
  const report: CorrectionReport = {
    correctionsMade: false,
    corrections: []
  };

  // Create a deep copy of the patches array to avoid mutating the original
  const correctedPatches: DiffParsedPatch[] = patches.map(patch => {
    // Deep copy of patch
    const copiedPatch: DiffParsedPatch = {
      oldFileName: patch.oldFileName,
      newFileName: patch.newFileName,
      hunks: patch.hunks.map(hunk => ({
        oldStart: hunk.oldStart,
        oldLines: hunk.oldLines,
        newStart: hunk.newStart,
        newLines: hunk.newLines,
        lines: [...hunk.lines] // Create a new array for lines
      }))
    };
    return copiedPatch;
  });

  // Process each patch
  correctedPatches.forEach((patch, patchIndex) => {
    // Determine the file path for this patch
    const filePath = extractFilePath(patch) || `unknown-file-${patchIndex}`;

    // Process each hunk in the patch
    patch.hunks.forEach((hunk, hunkIndex) => {
      // Initialize counters for actual lines
      let actualOldLines = 0;
      let actualNewLines = 0;

      // Count actual lines in a single pass through the hunk.lines array
      for (const line of hunk.lines) {
        // Skip metadata lines about missing newlines
        if (line === '\\ No newline at end of file') {
          continue;
        }

        // Count lines based on their prefix
        if (line.startsWith(' ')) {
          // Context lines count towards both old and new
          actualOldLines++;
          actualNewLines++;
        } else if (line.startsWith('-')) {
          // Removed lines count towards old only
          actualOldLines++;
        } else if (line.startsWith('+')) {
          // Added lines count towards new only
          actualNewLines++;
        }
        // Ignore any other lines (should not occur in a well-formed diff)
      }

      // Check if corrections are needed
      if (hunk.oldLines !== actualOldLines || hunk.newLines !== actualNewLines) {
        // Record that corrections were made
        report.correctionsMade = true;

        // Record the correction details
        report.corrections.push({
          filePath,
          hunkIndex,
          originalOld: hunk.oldLines,
          correctedOld: actualOldLines,
          originalNew: hunk.newLines,
          correctedNew: actualNewLines
        });

        // Update the line counts in the copied hunk
        hunk.oldLines = actualOldLines;
        hunk.newLines = actualNewLines;
      }
    });
  });

  return {
    correctedPatches,
    correctionDetails: report
  };
}